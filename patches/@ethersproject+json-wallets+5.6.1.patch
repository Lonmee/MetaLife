diff --git a/node_modules/@ethersproject/json-wallets/lib.esm/keystore.js b/node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
index da9e3f6..b0d0c83 100644
--- a/node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
+++ b/node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
@@ -9,12 +9,13 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
     });
 };
 import aes from "aes-js";
-import scrypt from "scrypt-js";
+import scrypt from "react-native-scrypt";
 import { getAddress } from "@ethersproject/address";
 import { arrayify, concat, hexlify } from "@ethersproject/bytes";
 import { defaultPath, entropyToMnemonic, HDNode, mnemonicToEntropy } from "@ethersproject/hdnode";
 import { keccak256 } from "@ethersproject/keccak256";
 import { pbkdf2 as _pbkdf2 } from "@ethersproject/pbkdf2";
+import { Aes } from "react-native-aes-crypto"
 import { randomBytes } from "@ethersproject/random";
 import { Description } from "@ethersproject/properties";
 import { computeAddress } from "@ethersproject/transactions";
@@ -80,6 +81,8 @@ function _getAccount(data, key) {
         const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
         try {
             const mnemonic = entropyToMnemonic(entropy, locale);
+            console.log(';;;s;s;ssssss')
+
             const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
             if (node.privateKey != account.privateKey) {
                 throw new Error("mnemonic mismatch");
@@ -173,6 +176,7 @@ export function encrypt(account, password, options, progressCallback) {
         // Check the mnemonic (if any) matches the private key
         if (hasMnemonic(account)) {
             const mnemonic = account.mnemonic;
+            console.log('ssdddddddddddddddddd')
             const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
             if (node.privateKey != account.privateKey) {
                 throw new Error("mnemonic mismatch");
@@ -262,6 +266,8 @@ export function encrypt(account, password, options, progressCallback) {
         // Encrypt the private key
         const counter = new aes.Counter(iv);
         const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);
+        console.log('1111111',derivedKey,iv,privateKey);
+
         const ciphertext = arrayify(aesCtr.encrypt(privateKey));
         // Compute the message authentication code, used to check the password
         const mac = keccak256(concat([macPrefix, ciphertext]));
diff --git a/node_modules/@ethersproject/json-wallets/lib/keystore.js b/node_modules/@ethersproject/json-wallets/lib/keystore.js
index 40e4207..7c1085b 100644
--- a/node_modules/@ethersproject/json-wallets/lib/keystore.js
+++ b/node_modules/@ethersproject/json-wallets/lib/keystore.js
@@ -56,17 +56,19 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.encrypt = exports.decrypt = exports.decryptSync = exports.KeystoreAccount = void 0;
 var aes_js_1 = __importDefault(require("aes-js"));
-var scrypt_js_1 = __importDefault(require("scrypt-js"));
+var scrypt_js_1 = __importDefault(require("react-native-scrypt"));
+var AES_js_1 = require("react-native-aes-crypto");
 var address_1 = require("@ethersproject/address");
 var bytes_1 = require("@ethersproject/bytes");
 var hdnode_1 = require("@ethersproject/hdnode");
 var keccak256_1 = require("@ethersproject/keccak256");
-var pbkdf2_1 = require("@ethersproject/pbkdf2");
 var random_1 = require("@ethersproject/random");
 var properties_1 = require("@ethersproject/properties");
 var transactions_1 = require("@ethersproject/transactions");
 var utils_1 = require("./utils");
+var strings_1 = require("@ethersproject/strings");
 var logger_1 = require("@ethersproject/logger");
+var buffer_1 = require("buffer");
 var _version_1 = require("./_version");
 var logger = new logger_1.Logger(_version_1.version);
 // Exported Types
@@ -95,66 +97,103 @@ function _decrypt(data, key, ciphertext) {
     return null;
 }
 function _getAccount(data, key) {
-    var ciphertext = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/ciphertext"));
-    var computedMAC = (0, bytes_1.hexlify)((0, keccak256_1.keccak256)((0, bytes_1.concat)([key.slice(16, 32), ciphertext]))).substring(2);
-    if (computedMAC !== (0, utils_1.searchPath)(data, "crypto/mac").toLowerCase()) {
-        throw new Error("invalid password");
-    }
-    var privateKey = _decrypt(data, key.slice(0, 16), ciphertext);
-    if (!privateKey) {
-        logger.throwError("unsupported cipher", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
-            operation: "decrypt"
-        });
-    }
-    var mnemonicKey = key.slice(32, 64);
-    var address = (0, transactions_1.computeAddress)(privateKey);
-    if (data.address) {
-        var check = data.address.toLowerCase();
-        if (check.substring(0, 2) !== "0x") {
-            check = "0x" + check;
-        }
-        if ((0, address_1.getAddress)(check) !== address) {
-            throw new Error("address mismatch");
-        }
-    }
-    var account = {
-        _isKeystoreAccount: true,
-        address: address,
-        privateKey: (0, bytes_1.hexlify)(privateKey)
-    };
-    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase
-    if ((0, utils_1.searchPath)(data, "x-ethers/version") === "0.1") {
-        var mnemonicCiphertext = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "x-ethers/mnemonicCiphertext"));
-        var mnemonicIv = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "x-ethers/mnemonicCounter"));
-        var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);
-        var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
-        var path = (0, utils_1.searchPath)(data, "x-ethers/path") || hdnode_1.defaultPath;
-        var locale = (0, utils_1.searchPath)(data, "x-ethers/locale") || "en";
-        var entropy = (0, bytes_1.arrayify)(mnemonicAesCtr.decrypt(mnemonicCiphertext));
+    return new Promise((resolve,reject)=>{
         try {
-            var mnemonic = (0, hdnode_1.entropyToMnemonic)(entropy, locale);
-            var node = hdnode_1.HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
-            if (node.privateKey != account.privateKey) {
-                throw new Error("mnemonic mismatch");
+            var ciphertext = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/ciphertext"));
+            var computedMAC = (0, bytes_1.hexlify)((0, keccak256_1.keccak256)((0, bytes_1.concat)([key.slice(16, 32), ciphertext]))).substring(2);
+            if (computedMAC !== (0, utils_1.searchPath)(data, "crypto/mac").toLowerCase()) {
+                throw new Error("invalid password");
             }
-            account.mnemonic = node.mnemonic;
-        }
-        catch (error) {
-            // If we don't have the locale wordlist installed to
-            // read this mnemonic, just bail and don't set the
-            // mnemonic
-            if (error.code !== logger_1.Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
-                throw error;
+            var privateKey = _decrypt(data, key.slice(0, 16), ciphertext);
+            if (!privateKey) {
+                logger.throwError("unsupported cipher", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
+                    operation: "decrypt"
+                });
+            }
+            var mnemonicKey = key.slice(32, 64);
+            var address = (0, transactions_1.computeAddress)(privateKey);
+            if (data.address) {
+                var check = data.address.toLowerCase();
+                if (check.substring(0, 2) !== "0x") {
+                    check = "0x" + check;
+                }
+                if ((0, address_1.getAddress)(check) !== address) {
+                    throw new Error("address mismatch");
+                }
+            }
+            var account = {
+                _isKeystoreAccount: true,
+                address: address,
+                privateKey: (0, bytes_1.hexlify)(privateKey)
+            };
+            // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase
+            if ((0, utils_1.searchPath)(data, "x-ethers/version") === "0.1") {
+                var mnemonicCiphertext = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "x-ethers/mnemonicCiphertext"));
+                var mnemonicIv = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "x-ethers/mnemonicCounter"));
+                var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);
+                var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
+                var path = (0, utils_1.searchPath)(data, "x-ethers/path") || hdnode_1.defaultPath;
+                var locale = (0, utils_1.searchPath)(data, "x-ethers/locale") || "en";
+                var entropy = (0, bytes_1.arrayify)(mnemonicAesCtr.decrypt(mnemonicCiphertext));
+                try {
+                    var mnemonic = (0, hdnode_1.entropyToMnemonic)(entropy, locale);
+                    hdnode_1.HDNode.fromMnemonic(mnemonic, null, locale)
+                    .then(resNode=>{
+                        console.log('nodess',resNode);
+
+                        var node = resNode.derivePath(path);
+                        if (node.privateKey != account.privateKey) {
+                            reject(new Error("mnemonic mismatch"));
+                        }
+                        account.mnemonic = node.mnemonic;
+                        resolve(new KeystoreAccount(account)); 
+
+                    })
+                    .catch(err=>{
+                        reject(err);
+
+                    })
+                }
+                catch (error) {
+                    // If we don't have the locale wordlist installed to
+                    // read this mnemonic, just bail and don't set the
+                    // mnemonic
+                    if (error.code !== logger_1.Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
+                        throw error;
+                    }
+                }
+            }
+            else{
+                resolve(new KeystoreAccount(account)); 
             }
+        } catch (error) {
+            reject(error);
         }
-    }
-    return new KeystoreAccount(account);
+    })
+
+    
 }
 function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
-    return (0, bytes_1.arrayify)((0, pbkdf2_1.pbkdf2)(passwordBytes, salt, count, dkLen, prfFunc));
+    var resString;
+    var finished = false;
+    AES_js_1.Aes.pbkdf2((0, strings_1.toUtf8String)(passwordBytes), (0, strings_1.toUtf8String)(salt), count, dkLen)
+        .then(function (res) {
+        resString = res;
+    }).finally(function (err) {
+        finished = true;
+    });
+    while (!finished) { }
+    return (0, bytes_1.arrayify)(Buffer.from(resString, 'hex'));
 }
 function pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {
-    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
+    return new Promise(function (resolve, reject) {
+        AES_js_1.Aes.pbkdf2((0, strings_1.toUtf8String)(passwordBytes), (0, strings_1.toUtf8String)(salt), count, dkLen)
+            .then(function (res) {
+            resolve((0, bytes_1.arrayify)(Buffer.from(res, 'hex')));
+        })["catch"](function (err) {
+            reject(err);
+        });
+    });
 }
 function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
     var passwordBytes = (0, utils_1.getPassword)(password);
@@ -210,7 +249,7 @@ function decryptSync(json, password) {
     var key = _computeKdfKey(data, password, pbkdf2Sync, scrypt_js_1.default.syncScrypt);
     return _getAccount(data, key);
 }
-exports.decryptSync = decryptSync;
+// exports.decryptSync = decryptSync;
 function decrypt(json, password, progressCallback) {
     return __awaiter(this, void 0, void 0, function () {
         var data, key;
@@ -228,23 +267,42 @@ function decrypt(json, password, progressCallback) {
 }
 exports.decrypt = decrypt;
 function encrypt(account, password, options, progressCallback) {
-    try {
-        // Check the address matches the private key
-        if ((0, address_1.getAddress)(account.address) !== (0, transactions_1.computeAddress)(account.privateKey)) {
-            throw new Error("address/privateKey mismatch");
-        }
-        // Check the mnemonic (if any) matches the private key
-        if (hasMnemonic(account)) {
-            var mnemonic = account.mnemonic;
-            var node = hdnode_1.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || hdnode_1.defaultPath);
-            if (node.privateKey != account.privateKey) {
-                throw new Error("mnemonic mismatch");
+    return new Promise((resolve, reject)=>{
+        try {
+            // Check the address matches the private key
+            if ((0, address_1.getAddress)(account.address) !== (0, transactions_1.computeAddress)(account.privateKey)) {
+                throw new Error("address/privateKey mismatch");
+            }
+            // Check the mnemonic (if any) matches the private key
+            if (hasMnemonic(account)) {
+                var mnemonic = account.mnemonic;
+
+                hdnode_1.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale)
+                .then(hdnode=>{
+                    var node = hdnode.derivePath(mnemonic.path || hdnode_1.defaultPath)
+                    if (node.privateKey != account.privateKey) {
+                        reject(new Error("mnemonic mismatch"));
+                    }
+
+                    encryptSub(account, password, options, progressCallback,resolve,reject);
+
+                })
+                .catch(err=>{
+                    reject(err); 
+                })                
             }
+            else{
+                encryptSub(account, password, options, progressCallback,resolve,reject);
+            }
+
         }
-    }
-    catch (e) {
-        return Promise.reject(e);
-    }
+        catch (e) {
+            reject(e);
+        }
+    });
+}
+
+function encryptSub(account, password, options, progressCallback,resolve,reject){
     // The options are optional, so adjust the call as needed
     if (typeof (options) === "function" && !progressCallback) {
         progressCallback = options;
@@ -282,7 +340,7 @@ function encrypt(account, password, options, progressCallback) {
     if (options.iv) {
         iv = (0, bytes_1.arrayify)(options.iv);
         if (iv.length !== 16) {
-            throw new Error("invalid iv");
+            reject(new Error("invalid iv"));
         }
     }
     else {
@@ -293,7 +351,7 @@ function encrypt(account, password, options, progressCallback) {
     if (options.uuid) {
         uuidRandom = (0, bytes_1.arrayify)(options.uuid);
         if (uuidRandom.length !== 16) {
-            throw new Error("invalid uuid");
+            reject(new Error("invalid uuid"));
         }
     }
     else {
@@ -312,10 +370,12 @@ function encrypt(account, password, options, progressCallback) {
             p = options.scrypt.p;
         }
     }
+
     // We take 64 bytes:
     //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
     //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)
-    return scrypt_js_1.default.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then(function (key) {
+    scrypt_js_1.default.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback)
+    .then(function (key) {
         key = (0, bytes_1.arrayify)(key);
         // This will be used to encrypt the wallet (as per Web3 secret storage)
         var derivedKey = key.slice(0, 16);
@@ -323,9 +383,13 @@ function encrypt(account, password, options, progressCallback) {
         // This will be used to encrypt the mnemonic phrase (if any)
         var mnemonicKey = key.slice(32, 64);
         // Encrypt the private key
+        var start = performance.now();
+
         var counter = new aes_js_1.default.Counter(iv);
         var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(derivedKey, counter);
         var ciphertext = (0, bytes_1.arrayify)(aesCtr.encrypt(privateKey));
+        var end = performance.now();
+        console.log('aes done', `${end - start}ms\n`);
         // Compute the message authentication code, used to check the password
         var mac = (0, keccak256_1.keccak256)((0, bytes_1.concat)([macPrefix, ciphertext]));
         // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
@@ -373,7 +437,10 @@ function encrypt(account, password, options, progressCallback) {
                 version: "0.1"
             };
         }
-        return JSON.stringify(data);
+        resolve(JSON.stringify(data));
+    })
+    .catch(err=>{
+        reject(err); 
     });
 }
 exports.encrypt = encrypt;
diff --git a/node_modules/@ethersproject/json-wallets/src.ts/keystore.js b/node_modules/@ethersproject/json-wallets/src.ts/keystore.js
new file mode 100644
index 0000000..14b7f7e
--- /dev/null
+++ b/node_modules/@ethersproject/json-wallets/src.ts/keystore.js
@@ -0,0 +1,401 @@
+"use strict";
+var __extends = (this && this.__extends) || (function () {
+    var extendStatics = function (d, b) {
+        extendStatics = Object.setPrototypeOf ||
+            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
+            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
+        return extendStatics(d, b);
+    };
+    return function (d, b) {
+        if (typeof b !== "function" && b !== null)
+            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
+        extendStatics(d, b);
+        function __() { this.constructor = d; }
+        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
+    };
+})();
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __generator = (this && this.__generator) || function (thisArg, body) {
+    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
+    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
+    function verb(n) { return function (v) { return step([n, v]); }; }
+    function step(op) {
+        if (f) throw new TypeError("Generator is already executing.");
+        while (_) try {
+            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
+            if (y = 0, t) op = [op[0] & 2, t.value];
+            switch (op[0]) {
+                case 0: case 1: t = op; break;
+                case 4: _.label++; return { value: op[1], done: false };
+                case 5: _.label++; y = op[1]; op = [0]; continue;
+                case 7: op = _.ops.pop(); _.trys.pop(); continue;
+                default:
+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
+                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
+                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
+                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
+                    if (t[2]) _.ops.pop();
+                    _.trys.pop(); continue;
+            }
+            op = body.call(thisArg, _);
+        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
+        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
+    }
+};
+exports.__esModule = true;
+exports.encrypt = exports.decrypt = exports.decryptSync = exports.KeystoreAccount = void 0;
+var aes_js_1 = require("aes-js");
+var react_native_scrypt_1 = require("react-native-scrypt");
+var address_1 = require("@ethersproject/address");
+var bytes_1 = require("@ethersproject/bytes");
+var hdnode_1 = require("@ethersproject/hdnode");
+var keccak256_1 = require("@ethersproject/keccak256");
+var react_native_aes_crypto_1 = require("react-native-aes-crypto");
+var random_1 = require("@ethersproject/random");
+var properties_1 = require("@ethersproject/properties");
+var transactions_1 = require("@ethersproject/transactions");
+var utils_1 = require("./utils");
+var strings_1 = require("@ethersproject/strings");
+var logger_1 = require("@ethersproject/logger");
+var _version_1 = require("./_version");
+var logger = new logger_1.Logger(_version_1.version);
+// Exported Types
+function hasMnemonic(value) {
+    return (value != null && value.mnemonic && value.mnemonic.phrase);
+}
+var KeystoreAccount = /** @class */ (function (_super) {
+    __extends(KeystoreAccount, _super);
+    function KeystoreAccount() {
+        return _super !== null && _super.apply(this, arguments) || this;
+    }
+    KeystoreAccount.prototype.isKeystoreAccount = function (value) {
+        return !!(value && value._isKeystoreAccount);
+    };
+    return KeystoreAccount;
+}(properties_1.Description));
+exports.KeystoreAccount = KeystoreAccount;
+function _decrypt(data, key, ciphertext) {
+    var cipher = (0, utils_1.searchPath)(data, "crypto/cipher");
+    if (cipher === "aes-128-ctr") {
+        var iv = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/cipherparams/iv"));
+        var counter = new aes_js_1["default"].Counter(iv);
+        var aesCtr = new aes_js_1["default"].ModeOfOperation.ctr(key, counter);
+        return (0, bytes_1.arrayify)(aesCtr.decrypt(ciphertext));
+    }
+    return null;
+}
+function _getAccount(data, key) {
+    var ciphertext = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/ciphertext"));
+    var computedMAC = (0, bytes_1.hexlify)((0, keccak256_1.keccak256)((0, bytes_1.concat)([key.slice(16, 32), ciphertext]))).substring(2);
+    if (computedMAC !== (0, utils_1.searchPath)(data, "crypto/mac").toLowerCase()) {
+        throw new Error("invalid password");
+    }
+    var privateKey = _decrypt(data, key.slice(0, 16), ciphertext);
+    if (!privateKey) {
+        logger.throwError("unsupported cipher", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
+            operation: "decrypt"
+        });
+    }
+    var mnemonicKey = key.slice(32, 64);
+    var address = (0, transactions_1.computeAddress)(privateKey);
+    if (data.address) {
+        var check = data.address.toLowerCase();
+        if (check.substring(0, 2) !== "0x") {
+            check = "0x" + check;
+        }
+        if ((0, address_1.getAddress)(check) !== address) {
+            throw new Error("address mismatch");
+        }
+    }
+    var account = {
+        _isKeystoreAccount: true,
+        address: address,
+        privateKey: (0, bytes_1.hexlify)(privateKey)
+    };
+    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase
+    if ((0, utils_1.searchPath)(data, "x-ethers/version") === "0.1") {
+        var mnemonicCiphertext = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "x-ethers/mnemonicCiphertext"));
+        var mnemonicIv = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "x-ethers/mnemonicCounter"));
+        var mnemonicCounter = new aes_js_1["default"].Counter(mnemonicIv);
+        var mnemonicAesCtr = new aes_js_1["default"].ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
+        var path = (0, utils_1.searchPath)(data, "x-ethers/path") || hdnode_1.defaultPath;
+        var locale = (0, utils_1.searchPath)(data, "x-ethers/locale") || "en";
+        var entropy = (0, bytes_1.arrayify)(mnemonicAesCtr.decrypt(mnemonicCiphertext));
+        try {
+            var mnemonic = (0, hdnode_1.entropyToMnemonic)(entropy, locale);
+            var node = hdnode_1.HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
+            if (node.privateKey != account.privateKey) {
+                throw new Error("mnemonic mismatch");
+            }
+            account.mnemonic = node.mnemonic;
+        }
+        catch (error) {
+            // If we don't have the locale wordlist installed to
+            // read this mnemonic, just bail and don't set the
+            // mnemonic
+            if (error.code !== logger_1.Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
+                throw error;
+            }
+        }
+    }
+    return new KeystoreAccount(account);
+}
+function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
+    var resString;
+    var finished = false;
+    react_native_aes_crypto_1.Aes.pbkdf2((0, strings_1.toUtf8String)(passwordBytes), (0, strings_1.toUtf8String)(salt), count, dkLen)
+        .then(function (res) {
+        resString = res;
+        finished = true;
+    })["catch"](function (err) {
+        finished = true;
+    });
+    while (!finished) { }
+    return (0, bytes_1.arrayify)(Buffer.from(resString, 'hex'));
+}
+function pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {
+    return new Promise(function (resolve, reject) {
+        react_native_aes_crypto_1.Aes.pbkdf2((0, strings_1.toUtf8String)(passwordBytes), (0, strings_1.toUtf8String)(salt), count, dkLen)
+            .then(function (res) {
+            resolve((0, bytes_1.arrayify)(Buffer.from(res, 'hex')));
+        })["catch"](function (err) {
+            reject(err);
+        });
+    });
+}
+function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
+    var passwordBytes = (0, utils_1.getPassword)(password);
+    var kdf = (0, utils_1.searchPath)(data, "crypto/kdf");
+    if (kdf && typeof (kdf) === "string") {
+        var throwError = function (name, value) {
+            return logger.throwArgumentError("invalid key-derivation function parameters", name, value);
+        };
+        if (kdf.toLowerCase() === "scrypt") {
+            var salt = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/kdfparams/salt"));
+            var N = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/n"));
+            var r = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/r"));
+            var p = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/p"));
+            // Check for all required parameters
+            if (!N || !r || !p) {
+                throwError("kdf", kdf);
+            }
+            // Make sure N is a power of 2
+            if ((N & (N - 1)) !== 0) {
+                throwError("N", N);
+            }
+            var dkLen = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/dklen"));
+            if (dkLen !== 32) {
+                throwError("dklen", dkLen);
+            }
+            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);
+        }
+        else if (kdf.toLowerCase() === "pbkdf2") {
+            var salt = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/kdfparams/salt"));
+            var prfFunc = null;
+            var prf = (0, utils_1.searchPath)(data, "crypto/kdfparams/prf");
+            if (prf === "hmac-sha256") {
+                prfFunc = "sha256";
+            }
+            else if (prf === "hmac-sha512") {
+                prfFunc = "sha512";
+            }
+            else {
+                throwError("prf", prf);
+            }
+            var count = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/c"));
+            var dkLen = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/dklen"));
+            if (dkLen !== 32) {
+                throwError("dklen", dkLen);
+            }
+            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
+        }
+    }
+    return logger.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
+}
+function decryptSync(json, password) {
+    var data = JSON.parse(json);
+    var key = _computeKdfKey(data, password, pbkdf2Sync, react_native_scrypt_1["default"].syncScrypt);
+    return _getAccount(data, key);
+}
+exports.decryptSync = decryptSync;
+function decrypt(json, password, progressCallback) {
+    return __awaiter(this, void 0, void 0, function () {
+        var data, key;
+        return __generator(this, function (_a) {
+            switch (_a.label) {
+                case 0:
+                    data = JSON.parse(json);
+                    return [4 /*yield*/, _computeKdfKey(data, password, pbkdf2, react_native_scrypt_1["default"].scrypt, progressCallback)];
+                case 1:
+                    key = _a.sent();
+                    return [2 /*return*/, _getAccount(data, key)];
+            }
+        });
+    });
+}
+exports.decrypt = decrypt;
+function encrypt(account, password, options, progressCallback) {
+    try {
+        // Check the address matches the private key
+        if ((0, address_1.getAddress)(account.address) !== (0, transactions_1.computeAddress)(account.privateKey)) {
+            throw new Error("address/privateKey mismatch");
+        }
+        // Check the mnemonic (if any) matches the private key
+        if (hasMnemonic(account)) {
+            var mnemonic = account.mnemonic;
+            var node = hdnode_1.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || hdnode_1.defaultPath);
+            if (node.privateKey != account.privateKey) {
+                throw new Error("mnemonic mismatch");
+            }
+        }
+    }
+    catch (e) {
+        return Promise.reject(e);
+    }
+    // The options are optional, so adjust the call as needed
+    if (typeof (options) === "function" && !progressCallback) {
+        progressCallback = options;
+        options = {};
+    }
+    if (!options) {
+        options = {};
+    }
+    var privateKey = (0, bytes_1.arrayify)(account.privateKey);
+    var passwordBytes = (0, utils_1.getPassword)(password);
+    var entropy = null;
+    var path = null;
+    var locale = null;
+    if (hasMnemonic(account)) {
+        var srcMnemonic = account.mnemonic;
+        entropy = (0, bytes_1.arrayify)((0, hdnode_1.mnemonicToEntropy)(srcMnemonic.phrase, srcMnemonic.locale || "en"));
+        path = srcMnemonic.path || hdnode_1.defaultPath;
+        locale = srcMnemonic.locale || "en";
+    }
+    var client = options.client;
+    if (!client) {
+        client = "ethers.js";
+    }
+    // Check/generate the salt
+    var salt = null;
+    if (options.salt) {
+        salt = (0, bytes_1.arrayify)(options.salt);
+    }
+    else {
+        salt = (0, random_1.randomBytes)(32);
+        ;
+    }
+    // Override initialization vector
+    var iv = null;
+    if (options.iv) {
+        iv = (0, bytes_1.arrayify)(options.iv);
+        if (iv.length !== 16) {
+            throw new Error("invalid iv");
+        }
+    }
+    else {
+        iv = (0, random_1.randomBytes)(16);
+    }
+    // Override the uuid
+    var uuidRandom = null;
+    if (options.uuid) {
+        uuidRandom = (0, bytes_1.arrayify)(options.uuid);
+        if (uuidRandom.length !== 16) {
+            throw new Error("invalid uuid");
+        }
+    }
+    else {
+        uuidRandom = (0, random_1.randomBytes)(16);
+    }
+    // Override the scrypt password-based key derivation function parameters
+    var N = (1 << 17), r = 8, p = 1;
+    if (options.scrypt) {
+        if (options.scrypt.N) {
+            N = options.scrypt.N;
+        }
+        if (options.scrypt.r) {
+            r = options.scrypt.r;
+        }
+        if (options.scrypt.p) {
+            p = options.scrypt.p;
+        }
+    }
+    // We take 64 bytes:
+    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
+    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)
+    return react_native_scrypt_1["default"].scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then(function (key) {
+        key = (0, bytes_1.arrayify)(key);
+        // This will be used to encrypt the wallet (as per Web3 secret storage)
+        var derivedKey = key.slice(0, 16);
+        var macPrefix = key.slice(16, 32);
+        // This will be used to encrypt the mnemonic phrase (if any)
+        var mnemonicKey = key.slice(32, 64);
+        // Encrypt the private key
+        var counter = new aes_js_1["default"].Counter(iv);
+        var aesCtr = new aes_js_1["default"].ModeOfOperation.ctr(derivedKey, counter);
+        var ciphertext = (0, bytes_1.arrayify)(aesCtr.encrypt(privateKey));
+        react_native_aes_crypto_1.Aes.encrypt((0, strings_1.toUtf8String)(privateKey), Buffer.from(iv).toString('hex'), Buffer.from(derivedKey).toString('hex'), 'aes-128-ctr')
+            .then(function (res) {
+            console.log('--------', Buffer.from(res, 'hex'));
+            console.log('--------', ciphertext);
+        })["catch"](function (err) {
+            console.log('--------', err);
+        });
+        // Compute the message authentication code, used to check the password
+        var mac = (0, keccak256_1.keccak256)((0, bytes_1.concat)([macPrefix, ciphertext]));
+        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
+        var data = {
+            address: account.address.substring(2).toLowerCase(),
+            id: (0, utils_1.uuidV4)(uuidRandom),
+            version: 3,
+            Crypto: {
+                cipher: "aes-128-ctr",
+                cipherparams: {
+                    iv: (0, bytes_1.hexlify)(iv).substring(2)
+                },
+                ciphertext: (0, bytes_1.hexlify)(ciphertext).substring(2),
+                kdf: "scrypt",
+                kdfparams: {
+                    salt: (0, bytes_1.hexlify)(salt).substring(2),
+                    n: N,
+                    dklen: 32,
+                    p: p,
+                    r: r
+                },
+                mac: mac.substring(2)
+            }
+        };
+        // If we have a mnemonic, encrypt it into the JSON wallet
+        if (entropy) {
+            var mnemonicIv = (0, random_1.randomBytes)(16);
+            var mnemonicCounter = new aes_js_1["default"].Counter(mnemonicIv);
+            var mnemonicAesCtr = new aes_js_1["default"].ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
+            var mnemonicCiphertext = (0, bytes_1.arrayify)(mnemonicAesCtr.encrypt(entropy));
+            var now = new Date();
+            var timestamp = (now.getUTCFullYear() + "-" +
+                (0, utils_1.zpad)(now.getUTCMonth() + 1, 2) + "-" +
+                (0, utils_1.zpad)(now.getUTCDate(), 2) + "T" +
+                (0, utils_1.zpad)(now.getUTCHours(), 2) + "-" +
+                (0, utils_1.zpad)(now.getUTCMinutes(), 2) + "-" +
+                (0, utils_1.zpad)(now.getUTCSeconds(), 2) + ".0Z");
+            data["x-ethers"] = {
+                client: client,
+                gethFilename: ("UTC--" + timestamp + "--" + data.address),
+                mnemonicCounter: (0, bytes_1.hexlify)(mnemonicIv).substring(2),
+                mnemonicCiphertext: (0, bytes_1.hexlify)(mnemonicCiphertext).substring(2),
+                path: path,
+                locale: locale,
+                version: "0.1"
+            };
+        }
+        return JSON.stringify(data);
+    });
+}
+exports.encrypt = encrypt;
diff --git a/node_modules/@ethersproject/json-wallets/src.ts/keystore.ts b/node_modules/@ethersproject/json-wallets/src.ts/keystore.ts
index 41ea298..4fce06f 100644
--- a/node_modules/@ethersproject/json-wallets/src.ts/keystore.ts
+++ b/node_modules/@ethersproject/json-wallets/src.ts/keystore.ts
@@ -1,19 +1,20 @@
 "use strict";
 
 import aes from "aes-js";
-import scrypt from "scrypt-js";
+import scrypt from "react-native-scrypt";
 
 import { ExternallyOwnedAccount } from "@ethersproject/abstract-signer";
 import { getAddress } from "@ethersproject/address";
 import { arrayify, Bytes, BytesLike, concat, hexlify } from "@ethersproject/bytes";
 import { defaultPath, entropyToMnemonic, HDNode, Mnemonic, mnemonicToEntropy } from "@ethersproject/hdnode";
 import { keccak256 } from "@ethersproject/keccak256";
-import { pbkdf2 as _pbkdf2 } from "@ethersproject/pbkdf2";
+import { Aes } from "react-native-aes-crypto"
 import { randomBytes } from "@ethersproject/random";
 import { Description } from "@ethersproject/properties";
 import { computeAddress } from "@ethersproject/transactions";
 
 import { getPassword, looseArrayify, searchPath, uuidV4, zpad } from "./utils";
+import { toUtf8String } from "@ethersproject/strings";
 
 import { Logger } from "@ethersproject/logger";
 import { version } from "./_version";
@@ -148,11 +149,30 @@ type ScryptFunc<T> = (pw: Uint8Array, salt: Uint8Array, n: number, r: number, p:
 type Pbkdf2Func<T> = (pw: Uint8Array, salt: Uint8Array, c: number, dkLen: number, prfFunc: string) => T;
 
 function pbkdf2Sync(passwordBytes: Uint8Array, salt: Uint8Array, count: number, dkLen: number, prfFunc: string): Uint8Array {
-    return arrayify(_pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));
+    let resString;
+    var finished=false;
+    Aes.pbkdf2(toUtf8String(passwordBytes), toUtf8String(salt), count, dkLen)
+    .then(res=>{
+        resString = res;
+        finished = true;
+    })
+    .catch(err=>{
+        finished =true;
+    });
+    while(!finished){}
+    return arrayify(Buffer.from(resString,'hex'));
 }
 
 function pbkdf2(passwordBytes: Uint8Array, salt: Uint8Array, count: number, dkLen: number, prfFunc: string): Promise<Uint8Array> {
-    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
+    return new Promise((resolve,reject)=>{
+        Aes.pbkdf2(toUtf8String(passwordBytes), toUtf8String(salt), count, dkLen)
+        .then(res=>{
+            resolve(arrayify(Buffer.from(res,'hex')));
+        })
+        .catch(err=>{
+            reject(err);
+        });
+    });    
 }
 
 function _computeKdfKey<T>(data: any, password: Bytes | string, pbkdf2Func: Pbkdf2Func<T>, scryptFunc: ScryptFunc<T>, progressCallback?: ProgressCallback): T {
@@ -225,153 +245,174 @@ export async function decrypt(json: string, password: Bytes | string, progressCa
 
 
 export function encrypt(account: ExternallyOwnedAccount, password: Bytes | string, options?: EncryptOptions, progressCallback?: ProgressCallback): Promise<string> {
-
-    try {
-        // Check the address matches the private key
-        if (getAddress(account.address) !== computeAddress(account.privateKey)) {
-            throw new Error("address/privateKey mismatch");
-        }
-
-        // Check the mnemonic (if any) matches the private key
-        if (hasMnemonic(account)) {
-            const mnemonic = account.mnemonic;
-            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
-
-            if (node.privateKey != account.privateKey) {
-                throw new Error("mnemonic mismatch");
+    return new Promise((resolve,reject)=>{
+        try {
+            // Check the address matches the private key
+            if (getAddress(account.address) !== computeAddress(account.privateKey)) {
+                throw new Error("address/privateKey mismatch");
             }
-        }
-
-    } catch (e) {
-        return Promise.reject(e);
-    }
     
-    // The options are optional, so adjust the call as needed
-    if (typeof(options) === "function" && !progressCallback) {
-        progressCallback = options;
-        options = {};
-    }
-    if (!options) { options = {}; }
-
-    const privateKey: Uint8Array = arrayify(account.privateKey);
-    const passwordBytes = getPassword(password);
+            // Check the mnemonic (if any) matches the private key
+            if (hasMnemonic(account)) {
+                const mnemonic = account.mnemonic;
+                HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale)
+                .then(hdnode=>{
+                    const node = hdnode.derivePath(mnemonic.path || defaultPath);
+    
+                    if (node.privateKey != account.privateKey) {
+                        reject(new Error("mnemonic mismatch"));
+                    } 
+
+                    // The options are optional, so adjust the call as needed
+                    if (typeof(options) === "function" && !progressCallback) {
+                        progressCallback = options;
+                        options = {};
+                    }
+                    if (!options) { options = {}; }
+                
+                    const privateKey: Uint8Array = arrayify(account.privateKey);
+                    const passwordBytes = getPassword(password);
+                
+                    let entropy: Uint8Array = null
+                    let path: string = null;
+                    let locale: string = null;
+                    if (hasMnemonic(account)) {
+                        const srcMnemonic = account.mnemonic;
+                        entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
+                        path = srcMnemonic.path || defaultPath;
+                        locale = srcMnemonic.locale || "en";
+                    }
+                
+                    let client = options.client;
+                    if (!client) { client = "ethers.js"; }
+                
+                    // Check/generate the salt
+                    let salt: Uint8Array = null;
+                    if (options.salt) {
+                        salt = arrayify(options.salt);
+                    } else {
+                        salt = randomBytes(32);;
+                    }
+                
+                    // Override initialization vector
+                    let iv: Uint8Array = null;
+                    if (options.iv) {
+                        iv = arrayify(options.iv);
+                        if (iv.length !== 16) { throw new Error("invalid iv"); }
+                    } else {
+                    iv = randomBytes(16);
+                    }
+                
+                    // Override the uuid
+                    let uuidRandom: Uint8Array = null;
+                    if (options.uuid) {
+                        uuidRandom = arrayify(options.uuid);
+                        if (uuidRandom.length !== 16) { throw new Error("invalid uuid"); }
+                    } else {
+                        uuidRandom = randomBytes(16);
+                    }
+                
+                    // Override the scrypt password-based key derivation function parameters
+                    let N = (1 << 17), r = 8, p = 1;
+                    if (options.scrypt) {
+                        if (options.scrypt.N) { N = options.scrypt.N; }
+                        if (options.scrypt.r) { r = options.scrypt.r; }
+                        if (options.scrypt.p) { p = options.scrypt.p; }
+                    }
+                    // We take 64 bytes:
+                    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
+                    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)
+                    scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key) => {
+                        key = arrayify(key);
+                
+                        // This will be used to encrypt the wallet (as per Web3 secret storage)
+                        const derivedKey = key.slice(0, 16);
+                        const macPrefix = key.slice(16, 32);
+                
+                        // This will be used to encrypt the mnemonic phrase (if any)
+                        const mnemonicKey = key.slice(32, 64);
+                
+                        // Encrypt the private key
+                        const counter = new aes.Counter(iv);
+                        const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);
+                        const ciphertext = arrayify(aesCtr.encrypt(privateKey));
+                        Aes.encrypt(toUtf8String(privateKey),Buffer.from(iv).toString('hex'),Buffer.from(derivedKey).toString('hex'),'aes-128-ctr')
+                        .then(function (res){
+                            console.log('--------',Buffer.from(res,'hex'));
+                            console.log('--------',ciphertext);
+                        })
+                        .catch(function (err){
+                            console.log('--------',err);
+                        })
+                        // Compute the message authentication code, used to check the password
+                        const mac = keccak256(concat([macPrefix, ciphertext]))
+                
+                        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
+                        const data: { [key: string]: any } = {
+                            address: account.address.substring(2).toLowerCase(),
+                            id: uuidV4(uuidRandom),
+                            version: 3,
+                            Crypto: {
+                                cipher: "aes-128-ctr",
+                                cipherparams: {
+                                    iv: hexlify(iv).substring(2),
+                                },
+                                ciphertext: hexlify(ciphertext).substring(2),
+                                kdf: "scrypt",
+                                kdfparams: {
+                                    salt: hexlify(salt).substring(2),
+                                    n: N,
+                                    dklen: 32,
+                                    p: p,
+                                    r: r
+                                },
+                                mac: mac.substring(2)
+                            }
+                        };
+                
+                        // If we have a mnemonic, encrypt it into the JSON wallet
+                        if (entropy) {
+                            const mnemonicIv = randomBytes(16);
+                            const mnemonicCounter = new aes.Counter(mnemonicIv);
+                            const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
+                            const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
+                            const now = new Date();
+                            const timestamp = (now.getUTCFullYear() + "-" +
+                                            zpad(now.getUTCMonth() + 1, 2) + "-" +
+                                            zpad(now.getUTCDate(), 2) + "T" +
+                                            zpad(now.getUTCHours(), 2) + "-" +
+                                            zpad(now.getUTCMinutes(), 2) + "-" +
+                                            zpad(now.getUTCSeconds(), 2) + ".0Z"
+                                            );
+                            data["x-ethers"] = {
+                                client: client,
+                                gethFilename: ("UTC--" + timestamp + "--" + data.address),
+                                mnemonicCounter: hexlify(mnemonicIv).substring(2),
+                                mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
+                                path: path,
+                                locale: locale,
+                                version: "0.1"
+                            };
+                        }
+                
+                        resolve(JSON.stringify(data));
+                    })
+                    .catch(err=>{
+                        reject(err);
+                    });
+
+                })
+                .catch(err=>{
+                    reject(err);
+                })
                 
-    let entropy: Uint8Array = null
-    let path: string = null;
-    let locale: string = null;
-    if (hasMnemonic(account)) {
-        const srcMnemonic = account.mnemonic;
-        entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
-        path = srcMnemonic.path || defaultPath;
-        locale = srcMnemonic.locale || "en";
-    }
                 
-    let client = options.client;
-    if (!client) { client = "ethers.js"; }
-
-    // Check/generate the salt
-    let salt: Uint8Array = null;
-    if (options.salt) {
-        salt = arrayify(options.salt);
-    } else {
-        salt = randomBytes(32);;
-    }
-
-    // Override initialization vector
-    let iv: Uint8Array = null;
-    if (options.iv) {
-        iv = arrayify(options.iv);
-        if (iv.length !== 16) { throw new Error("invalid iv"); }
-    } else {
-       iv = randomBytes(16);
-    }
-
-    // Override the uuid
-    let uuidRandom: Uint8Array = null;
-    if (options.uuid) {
-        uuidRandom = arrayify(options.uuid);
-        if (uuidRandom.length !== 16) { throw new Error("invalid uuid"); }
-    } else {
-        uuidRandom = randomBytes(16);
-    }
-
-    // Override the scrypt password-based key derivation function parameters
-    let N = (1 << 17), r = 8, p = 1;
-    if (options.scrypt) {
-        if (options.scrypt.N) { N = options.scrypt.N; }
-        if (options.scrypt.r) { r = options.scrypt.r; }
-        if (options.scrypt.p) { p = options.scrypt.p; }
-    }
-
-    // We take 64 bytes:
-    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
-    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)
-    return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key) => {
-        key = arrayify(key);
-
-        // This will be used to encrypt the wallet (as per Web3 secret storage)
-        const derivedKey = key.slice(0, 16);
-        const macPrefix = key.slice(16, 32);
-
-        // This will be used to encrypt the mnemonic phrase (if any)
-        const mnemonicKey = key.slice(32, 64);
-
-        // Encrypt the private key
-        const counter = new aes.Counter(iv);
-        const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);
-        const ciphertext = arrayify(aesCtr.encrypt(privateKey));
-
-        // Compute the message authentication code, used to check the password
-        const mac = keccak256(concat([macPrefix, ciphertext]))
-
-        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
-        const data: { [key: string]: any } = {
-            address: account.address.substring(2).toLowerCase(),
-            id: uuidV4(uuidRandom),
-            version: 3,
-            Crypto: {
-                cipher: "aes-128-ctr",
-                cipherparams: {
-                    iv: hexlify(iv).substring(2),
-                },
-                ciphertext: hexlify(ciphertext).substring(2),
-                kdf: "scrypt",
-                kdfparams: {
-                    salt: hexlify(salt).substring(2),
-                    n: N,
-                    dklen: 32,
-                    p: p,
-                    r: r
-                },
-                mac: mac.substring(2)
             }
-        };
-
-        // If we have a mnemonic, encrypt it into the JSON wallet
-        if (entropy) {
-            const mnemonicIv = randomBytes(16);
-            const mnemonicCounter = new aes.Counter(mnemonicIv);
-            const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
-            const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
-            const now = new Date();
-            const timestamp = (now.getUTCFullYear() + "-" +
-                               zpad(now.getUTCMonth() + 1, 2) + "-" +
-                               zpad(now.getUTCDate(), 2) + "T" +
-                               zpad(now.getUTCHours(), 2) + "-" +
-                               zpad(now.getUTCMinutes(), 2) + "-" +
-                               zpad(now.getUTCSeconds(), 2) + ".0Z"
-                              );
-            data["x-ethers"] = {
-                client: client,
-                gethFilename: ("UTC--" + timestamp + "--" + data.address),
-                mnemonicCounter: hexlify(mnemonicIv).substring(2),
-                mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
-                path: path,
-                locale: locale,
-                version: "0.1"
-            };
+    
+        } catch (e) {
+            reject(e);
         }
     
-        return JSON.stringify(data);
-    });
+    })
+    
 }
