diff --git a/node_modules/react-native-web3-wallet/index.js b/node_modules/react-native-web3-wallet/index.js
index 51551ba..c8b726b 100644
--- a/node_modules/react-native-web3-wallet/index.js
+++ b/node_modules/react-native-web3-wallet/index.js
@@ -37,36 +37,39 @@ export function createWallet(password, path = "m/44'/60'/0'/0/0", seedByte = 16,
             var end = performance.now();
             console.log('mnemonic done', `${end - start}ms\n`);
         
-            let wallet = ethers.Wallet.fromMnemonic(mnemonic, path);
-        
-            end = performance.now();
-            console.log('wallet init', `${end - start}ms\n`);
-            
-            let mnemonicArr = mnemonic.split(' ');
-            let shuffleMnemonicArr = mnemonicArr.slice().shuffle();
-
-            wallet.encrypt(password).then(res=>{
+            ethers.Wallet.fromMnemonic(mnemonic, path)
+            .then(wallet=>{
                 end = performance.now();
-                let jsonObj = JSON.parse(res);
-                delete jsonObj['x-ethers'];
-                
-                let response = {
-                    mnemonic : mnemonicArr, 
-                    keystore : jsonObj,
-                    shuffleMnemonic : shuffleMnemonicArr,
-                };
-                if(needPublicKey){
-                    response.publicKey=wallet.publicKey;
-                }
-                if(needPrivateKey){
-                    response.privateKey=wallet.privateKey;
-                }
+                console.log('wallet init', `${end - start}ms\n`);
+            
+                let mnemonicArr = mnemonic.split(' ');
+                let shuffleMnemonicArr = mnemonicArr.slice().shuffle();
+
+                wallet.encrypt(password).then(res=>{
+                    end = performance.now();
+                    let jsonObj = JSON.parse(res);                
+                    let response = {
+                        mnemonic : mnemonicArr, 
+                        keystore : jsonObj,
+                        shuffleMnemonic : shuffleMnemonicArr,
+                    };
+                    if(needPublicKey){
+                        response.publicKey=wallet.publicKey;
+                    }
+                    if(needPrivateKey){
+                        response.privateKey=wallet.privateKey;
+                    }
 
-                fulfill(response)
+                    fulfill(response);
+                })
+                .catch(err=>{
+                    reject(err);
+                }); 
             })
             .catch(err=>{
                 reject(err);
             }); 
+            
         } catch (error) {
             reject(error);
         }
@@ -176,8 +179,13 @@ export function getContractNfts(network, contractAddress, contractAbi, address){
 export function exportPrivateKeyFromMnemonic(mnemonic, path){
     return new Promise((fulfill, reject)=>{
         try {
-            let wallet = ethers.Wallet.fromMnemonic(mnemonic, path)
-            fulfill(wallet.privateKey);
+            ethers.Wallet.fromMnemonic(mnemonic, path)
+            .then(wallet=>{
+                fulfill(wallet.privateKey);
+            })
+            .catch(err=>{
+                reject(err);
+            })
         } catch (error) {
             reject(error);
         }
@@ -195,6 +203,23 @@ export function exportPrivateKeyFromKeystore(keystore, password){
     });
 }
 
+export function exportMnemonicFromKeystore(keystore, password){
+    return new Promise((fulfill, reject)=>{
+        ethers.Wallet.fromEncryptedJson(keystore,password).then(res=>{
+            let mnemonicArr = res.mnemonic.split(' ');
+            let shuffleMnemonicArr = mnemonicArr.slice().shuffle();
+
+            fulfill({
+                mnemonic : mnemonicArr, 
+                shuffleMnemonic : shuffleMnemonicArr,     
+            });
+        })
+        .catch(err=>{
+            reject(err);
+        });
+    });
+}
+
 export function exportKeystore(keystore, password){
     return new Promise((fulfill, reject)=>{
         ethers.Wallet.fromEncryptedJson(keystore,password).then(res=>{
@@ -217,8 +242,6 @@ export function importPrivateKey(privateKey, password, needPrivateKey = false, n
             let wallet = new ethers.Wallet(realPrivatekey);
             wallet.encrypt(password).then(res=>{
                 let jsonObj = JSON.parse(res);
-                delete jsonObj['x-ethers'];
-
                 let response = {
                     keystore : jsonObj,
                 };
@@ -243,25 +266,29 @@ export function importPrivateKey(privateKey, password, needPrivateKey = false, n
 export function importMnemonic(mnemonic, password, path = "m/44'/60'/0'/0/0", needPrivateKey = false, needPublicKey = false){
     return new Promise((fulfill, reject)=>{
         try {
-            let wallet = ethers.Wallet.fromMnemonic(mnemonic, path);
-            wallet.encrypt(password).then(res=>{
-                let jsonObj = JSON.parse(res);
-                delete jsonObj['x-ethers'];
-
-                let response = {
-                    keystore : jsonObj,
-                };
-                if(needPublicKey){
-                    response.publicKey=res.publicKey;
-                }
-                if(needPrivateKey){
-                    response.privateKey=res.privateKey;
-                }
-                fulfill(response);
+            ethers.Wallet.fromMnemonic(mnemonic, path)
+            .then(wallet=>{
+                wallet.encrypt(password).then(res=>{
+                    let jsonObj = JSON.parse(res);    
+                    let response = {
+                        keystore : jsonObj,
+                    };
+                    if(needPublicKey){
+                        response.publicKey=res.publicKey;
+                    }
+                    if(needPrivateKey){
+                        response.privateKey=res.privateKey;
+                    }
+                    fulfill(response);
+                })
+                .catch(err=>{
+                    reject(err);
+                });
             })
             .catch(err=>{
                 reject(err);
             });
+            
         } catch (error) {
             reject(error);
         }
