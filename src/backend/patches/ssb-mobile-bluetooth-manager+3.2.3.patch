diff --git a/node_modules/ssb-mobile-bluetooth-manager/index.js b/node_modules/ssb-mobile-bluetooth-manager/index.js
index 536f9f6..4a9fc18 100644
--- a/node_modules/ssb-mobile-bluetooth-manager/index.js
+++ b/node_modules/ssb-mobile-bluetooth-manager/index.js
@@ -14,19 +14,20 @@ const uuidv4 = require('uuid/v4');
 const debug = require('debug')('ssb-mobile-bluetooth-manager');
 
 const EventEmitter = require('events');
-
+const rnBridge = require('rn-bridge');
 const delayedDeviceScanSource = pullDefer.source();
 
+const localHost='127.0.0.1';
+
 let scanActive = false;
 
 function makeManager (opts) {
 
   const bluetoothScanStateEmitter = new EventEmitter();
 
-  if (!opts || !opts.socketFolderPath) {
-    throw new Error("ssb-mobile-bluetooth-manager must be configured with a socketFolderPath option.");
-  }
-
+  // if (!opts || !opts.socketFolderPath) {
+  //   throw new Error("ssb-mobile-bluetooth-manager must be configured with a socketFolderPath option.");
+  // }
   if (!opts || !opts.myIdent) {
     throw new Error("ssb-mobile-bluetooth-manager must be configured with the myIdent option.")
   }
@@ -35,15 +36,15 @@ function makeManager (opts) {
     throw new Error("ssb-mobile-bluetooth-manager must be configured with a metadataServiceUUID option.");
   }
 
-  if (!opts || !opts.controlSocketFilename) {
+  if (!opts || !opts.controlPort) {
     throw new Error("ssb-mobile-bluetooth-manager must be configured with a controlSocketFilename option.");
   }
 
-  if (!opts || !opts.incomingSocketFilename) {
+  if (!opts || !opts.incomingPort) {
     throw new Error("ssb-mobile-bluetooth-manager must be configured with a incomingSocketFilename option.");
   }
 
-  if (!opts || !opts.outgoingSocketFilename) {
+  if (!opts || !opts.outgoingPort) {
     throw new Error("ssb-mobile-bluetooth-manager must be configured with a outgoingSocketFilename option.");
   }
 
@@ -104,12 +105,12 @@ function makeManager (opts) {
   function makeControlSocket() {
     if (controlSocketEstablished) return;
 
-    var address = opts.socketFolderPath + "/" + opts.controlSocketFilename;
+    // var address = opts.socketFolderPath + "/" + opts.controlSocketFilename;
 
-    try {
-      fs.unlinkSync(address);
-    } catch (error) {
-    }
+    // try {
+    //   fs.unlinkSync(address);
+    // } catch (error) {
+    // }
 
     var controlSocket = net.createServer(function(stream){
 
@@ -125,13 +126,20 @@ function makeManager (opts) {
       // Receive and process commands from the control server
       pull(duplexConnection.source, pullJson.parse(), pull.drain(doCommand));
 
-    }).listen(address);
+    }).listen({host:localHost,port:opts.controlPort});
 
     controlSocketEstablished = true;
 
     controlSocket.on('closed', function() {
       debug("Control socket closed");
+      rnBridge.channel.post('log4RN', "Control socket closed");
+
+    })
+    controlSocket.on('error', function(err) {
+      debug("Control socket error",err);
+      rnBridge.channel.post('exception', err);
     })
+    rnBridge.channel.post('log4RN', 'control socket create');
 
     debug("Created control socket");
   }
@@ -154,9 +162,13 @@ function makeManager (opts) {
 
         if (connectionOutcome.success) {
           debug("Calling back multiserve with successful outgoing connection to " + outgoingAddress);
+          rnBridge.channel.post('log4RN', "Calling back multiserve with successful outgoing connection to " + outgoingAddress);
+
           cb(null, stream);
         } else {
-          debug("Calling back with unsuccessful connection to multiserver for address: " + outgoingAddress)
+          debug("Calling back with unsuccessful connection to multiserver for address: " + outgoingAddress);
+          rnBridge.channel.post('log4RN', "Calling back with unsuccessful connection to multiserver for address: " + outgoingAddress);
+
           cb(new Error(connectionOutcome.failureReason));
         }
       })
@@ -169,6 +181,7 @@ function makeManager (opts) {
         let address = results[1].address;
 
         stream.address = address;
+        rnBridge.channel.post('log4RN', 'incoming bluetooth connection:' + JSON.stringify(stream));
 
         debug("Calling back to multiserve with incoming bluetooth connection from " + address);
         onIncomingConnection(null, stream);
@@ -189,6 +202,8 @@ function makeManager (opts) {
     debug("Received command: ");
     debug(command);
 
+    rnBridge.channel.post('log4RN', 'Received command:' + JSON.stringify(command));
+
     let commandName = command.command;
 
     if (commandName === "connected" && !command.arguments.isIncoming) {
@@ -303,19 +318,19 @@ function makeManager (opts) {
   }
 
   function listenForOutgoingEstablished() {
-    var address = opts.socketFolderPath + "/" + opts.outgoingSocketFilename;
+    // var address = opts.socketFolderPath + "/" + opts.outgoingSocketFilename;
 
-    try {
-      fs.unlinkSync(address);
-    } catch (error) {
+    // try {
+    //   fs.unlinkSync(address);
+    // } catch (error) {
 
-    }
+    // }
 
     var server = net.createServer(function(stream){
       debug("bluetooth: Outgoing connection established proxy connection.")
 
       var item = {
-        stream: logDuplexStreams(toPull.duplex(stream))
+        stream: logDuplexStreams(toPull.duplex(stream), 'outgoing')
       }
 
       outgoingConnectionsEstablished.push(item);
@@ -326,8 +341,19 @@ function makeManager (opts) {
       debug("Server listening for outgoing connections. Starting control unix socket.");
       makeControlSocket();
     });
+    server.on('close', function (e) {
+      rnBridge.channel.post('log4RN', "outgoing socket closed: " + e);
+
+      debug("bt_bridge socket closed: " + e);
+    });
+    server.on('error', function(err) {
+      debug("outgoing socket error",err);
+      rnBridge.channel.post('exception', err);
+    });
+
+    rnBridge.channel.post('log4RN', 'outgoing socket create');
 
-    return server.listen(address);
+    return server.listen({host:localHost,port:opts.outgoingPort});
   }
 
   // For some reason, .server gets called twice...
@@ -339,27 +365,36 @@ function makeManager (opts) {
 
     if(started) return
 
-    var socket = opts.socketFolderPath + "/" + opts.incomingSocketFilename;
-    try {
-      fs.unlinkSync(socket);
-    } catch (error) {
+    // var socket = opts.socketFolderPath + "/" + opts.incomingSocketFilename;
+    // try {
+    //   fs.unlinkSync(socket);
+    // } catch (error) {
 
-    }
+    // }
 
     var server = net.createServer(function (incomingStream) {
 
       // We only call back with the connection when we later receive the address over the control
       // bridge. See the 'onCommand' function.
 
-      incomingConnectionEstablished.push({
-        stream: logDuplexStreams( toPull.duplex(incomingStream) )
-      })
+      var item = {
+        stream: logDuplexStreams(toPull.duplex(incomingStream), 'incoming')
+      }
+      rnBridge.channel.post('log4RN', 'incoming socket stream:' + JSON.stringify(item.stream));
 
-    }).listen(socket);
+      incomingConnectionEstablished.push(item)
 
+    }).listen({host:localHost,port:opts.incomingPort});
+    server.on('error', function(err) {
+      debug("incoming socket error",err);
+      rnBridge.channel.post('exception', err);
+    })
     server.on('close', function (e) {
+      rnBridge.channel.post('log4RN', "incoming socket closed: " + e);
+
       debug("bt_bridge socket closed: " + e);
     });
+    rnBridge.channel.post('log4RN', 'incoming socket create');
 
     started = true;
 
@@ -492,6 +527,7 @@ function makeManager (opts) {
 
   function makeDeviceDiscoverable(forTime, cb) {
     debug("Making device discoverable");
+    rnBridge.channel.post('log4RN', 'Making device discoverable');
 
     if (awaitingDiscoverableResponse != null) {
       cb(new Error("Already requesting to make device discoverable."), null)
@@ -662,14 +698,15 @@ function makeManager (opts) {
    * If 'opts.logStreams' is true, logs out incoming and outgoing data streams.
    * @param {} duplexStream
    */
-  function logDuplexStreams(duplexStream) {
-    if (!opts.logStreams) {
-      return duplexStream;
-    } else {
+  function logDuplexStreams(duplexStream, tag) {
+    // if (!opts.logStreams) {
+    //   return duplexStream;
+    // } else {
 
       duplexStream.source = pull(duplexStream.source, pull.map(
         buff => {
           debug( "[source] " + buff.toString() )
+          rnBridge.channel.post('log4RN',  tag + "[source] " + buff.toString() );
           return buff;
         }
       ));
@@ -677,18 +714,20 @@ function makeManager (opts) {
       duplexStream.sink = pull(
         pull.map(outgoingBuff => {
           debug( "[sink] " + outgoingBuff.toString() )
+          rnBridge.channel.post('log4RN', tag + "[sink] " + outgoingBuff.toString());
           return outgoingBuff;
         }),
         duplexStream.sink
       )
 
       return duplexStream;
-    }
+    // }
   }
 
 
   listenForOutgoingEstablished();
   makeFullyEstablishConnectionsHandler();
+  rnBridge.channel.post('log4RN', 'bluetooth manager init');
 
   return {
     connect,
